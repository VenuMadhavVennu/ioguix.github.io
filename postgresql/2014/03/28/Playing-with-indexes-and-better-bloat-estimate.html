<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <title>Playing with indexes and better bloat estimate</title>
  <meta name="author" content="Jehan-Guillaume (ioguix) de Rorthais" />
  <link href="http://blog.ioguix.net/feed.xml" rel="alternate" title="Jehan-Guillaume (ioguix) de Rorthais" type="application/atom+xml" >
  <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />
  <link rel="stylesheet" href="/css/syntax.css" type="text/css" />
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
</head>
<body>

  <div class="header">
    <a class="title" href="/">ioguix' README</a>
  </div>


  

<div id="content">

  <hr />
  
  <div id="content_infos">
    28 March 2014
    
    <ul class="inline-list">
    
      <li><a href="http://blog.ioguix.net/postgresql/feed.xml">postgresql</a> <i class="fa fa-rss"></i></li>
    
    </ul>
    
    
    <ul class="inline-list">
    
      <li>
        <a href="/tag/bloat/">bloat</a>, 
      </li>
    
      <li>
        <a href="/tag/postgresql/">postgresql</a>
      </li>
    
      <li><i class="fa fa-tags"></i></li>
    </ul>
    
    
      <a href="#comments">4 comments</a>
     <i class="fa fa-comment"></i>
  </div>

  <h1>Playing with indexes and better bloat estimate</h1>

  <br style="clear: both" />

  <p>Most of the PostgreSQL DBAs might know about [this large bloat estimate query][http://wiki.postgresql.org/wiki/Show_database_bloat]
integrated in <a href="http://bucardo.org/wiki/Check_postgres">check_postgres</a>.  It is
supposed to compute a rough estimate of the bloat for tables and indexes in a
database.  As the PostgreSQL wiki page says:</p>

<blockquote>
  <p>This query is for informational purposes only.  It provides a loose estimate
of table growth activity only, and should not be construed as a 100% accurate
portrayal of space consumed by database objects</p>
</blockquote>

<p>Lately, a customer asked me about existing tools to help deciding when he is
supposed to <code>REINDEX</code>.  While writing a detailed answer with examples, I had
quite a surprise seeing an estimated index size ratio of 0.7 for a simple
table!  I realized I never payed much attention to this part of the result…</p>

<h2 id="the-problem">The problem</h2>

<p>Here is a test table, a copy table <code>rental</code> from
<a href="http://pgfoundry.org/frs/download.php/1719/pagila-0.10.1.zip">pagila</a> project:</p>

<figure class="highlight"><pre><code class="language-psql" data-lang="psql"><span></span><span class="gp">pagila=#</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">test</span> <span class="p">(</span><span class="k">LIKE</span> <span class="n">rental</span> <span class="k">INCLUDING</span> <span class="k">DEFAULTS</span> <span class="k">INCLUDING</span> <span class="k">CONSTRAINTS</span> <span class="k">INCLUDING</span> <span class="k">INDEXES</span> <span class="p">);</span>
<span class="gp">pagila=#</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">test</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">rental</span><span class="p">;</span>
<span class="gp">pagila=#</span> <span class="k">ANALYZE</span><span class="p">;</span>
<span class="gp">pagila=#</span> <span class="kp">\d</span> <span class="ss">test</span>
<span class="go">                                           Table &quot;public.test&quot;</span>
<span class="go">    Column    |            Type             |                         Modifiers                          </span>
<span class="go">--------------+-----------------------------+------------------------------------------------------------</span>
<span class="go"> rental_id    | integer                     | not null default nextval(&#39;rental_rental_id_seq&#39;::regclass)</span>
<span class="go"> rental_date  | timestamp without time zone | not null</span>
<span class="go"> inventory_id | integer                     | not null</span>
<span class="go"> customer_id  | smallint                    | not null</span>
<span class="go"> return_date  | timestamp without time zone | </span>
<span class="go"> staff_id     | smallint                    | not null</span>
<span class="go"> last_update  | timestamp without time zone | not null default now()</span>
<span class="go">Indexes:</span>
<span class="go">    &quot;test_pkey&quot; PRIMARY KEY, btree (rental_id)</span>
<span class="go">    &quot;test_rental_date_inventory_id_customer_id_idx&quot; UNIQUE, btree (rental_date, inventory_id, customer_id)</span>
<span class="go">    &quot;test_inventory_id_idx&quot; btree (inventory_id)</span></code></pre></figure>

<p>I copy pasted the bloat query in file <code>~/tmp/bloat_original.sql</code>, here is its output for this table:</p>

<figure class="highlight"><pre><code class="language-psql" data-lang="psql"><span></span><span class="gp">postgres@pagila=#</span> <span class="kp">\i</span> <span class="ss">~/tmp/bloat_original.sql</span>
<span class="go"> current_database | schemaname |    tablename     | tbloat | wastedbytes |                        iname                        | ibloat | wastedibytes </span>
<span class="go">------------------+------------+------------------+--------+-------------+-----------------------------------------------------+--------+--------------</span>
<span class="go">...</span>
<span class="go"> pagila           | public     | test             |    1.2 |      188416 | test_pkey                                           |    0.5 |            0</span>
<span class="go"> pagila           | public     | test             |    1.2 |      188416 | test_rental_date_inventory_id_customer_id_idx       |    0.8 |            0</span>
<span class="go"> pagila           | public     | test             |    1.2 |      188416 | test_inventory_id_idx                               |    0.7 |            0</span>
<span class="go">...</span></code></pre></figure>

<p>A B-tree index is filled at 90% per default, see storage parameter
<a href="http://www.postgresql.org/docs/9.3/static/sql-createindex.html#SQL-CREATEINDEX-STORAGE-PARAMETERS">FILL FACTOR</a>.
So, a freshly created B-tree index with no bloat is supposed to be 1.1x larger
than it should be with a <code>FILL FACTOR</code> of 100.  As I had some time
to dive in this, I couldn’t resist to investigate these insane estimated size
factors for my test table indexes: 0.5, 0.8 and 0.7.  How an index could be
smaller than it is supposed to be ?</p>

<p>I hadn’t to dive deap in the query, after a closer look at the query code and
comments, we find:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span></span><span class="n">COALESCE</span><span class="p">(</span><span class="n">CEIL</span><span class="p">((</span><span class="n">c2</span><span class="p">.</span><span class="n">reltuples</span><span class="o">*</span><span class="p">(</span><span class="n">datahdr</span><span class="o">-</span><span class="mi">12</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">bs</span><span class="o">-</span><span class="mi">20</span><span class="p">::</span><span class="nb">float</span><span class="p">)),</span><span class="mi">0</span><span class="p">)</span> <span class="k">AS</span> <span class="n">iotta</span> <span class="c1">-- very rough approximation, assumes all cols</span></code></pre></figure>

<p>Oh, ok. The query estimates the ideal size of each index considering it
references <em>ALL</em> the table fields.  It’s quite rare to find a btree index on
all fields of a table, and obviously there’s no point having multiple indexes
on a table, all of them referencing all fields of the table.</p>

<h2 id="a-look-at-the-real-bloat">A look at the real bloat</h2>

<p>First, let see how the indexes are really bloated:</p>

<figure class="highlight"><pre><code class="language-psql" data-lang="psql"><span></span><span class="gp">pagila=#</span> <span class="k">create</span> <span class="k">schema</span> <span class="n">stattuple</span><span class="p">;</span>
<span class="gp">pagila=#</span> <span class="k">create</span> <span class="k">extension</span> <span class="n">pgstattuple</span> <span class="k">with</span> <span class="k">schema</span> <span class="n">stattuple</span><span class="p">;</span>
<span class="gp">pagila=#</span> <span class="k">SELECT</span> <span class="n">relname</span><span class="p">,</span> <span class="n">pg_table_size</span><span class="p">(</span><span class="n">oid</span><span class="p">)</span> <span class="k">as</span> <span class="n">index_size</span><span class="p">,</span>
  <span class="mf">100</span><span class="o">-</span><span class="p">(</span><span class="n">stattuple</span><span class="mf">.</span><span class="n">pgstatindex</span><span class="p">(</span><span class="n">relname</span><span class="p">))</span><span class="mf">.</span><span class="n">avg_leaf_density</span> <span class="k">AS</span> <span class="n">bloat_ratio</span>
<span class="k">FROM</span> <span class="n">pg_class</span>
<span class="k">WHERE</span> <span class="n">relname</span> <span class="o">~</span> <span class="s1">&#39;test&#39;</span> <span class="k">AND</span> <span class="n">relkind</span> <span class="o">=</span> <span class="s1">&#39;i&#39;</span><span class="p">;</span>

<span class="go">                    relname                    | index_size | bloat_ratio </span>
<span class="go">-----------------------------------------------+------------+-------------</span>
<span class="go"> test_pkey                                     |     376832 |       10.25</span>
<span class="go"> test_inventory_id_idx                         |     507904 |       34.11</span>
<span class="go"> test_rental_date_inventory_id_customer_id_idx |     630784 |       26.14</span></code></pre></figure>

<p>First point, the bloat on indexes is not 10% everywhere, only for the PK. This
is because indexes were created <em>BEFORE</em> inserting data.  So it looks like data
were naturally order on the PK on table “rental” when scanning it sequentially.
What if we load data sorting on “inventory_id” field ?</p>

<figure class="highlight"><pre><code class="language-psql" data-lang="psql"><span></span><span class="gp">pagila=#</span> <span class="k">TRUNCATE</span> <span class="n">test</span><span class="p">;</span>
<span class="gp">pagila=#</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">test</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">rental</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">inventory_id</span> <span class="p">;</span>
<span class="gp">pagila=#</span> <span class="k">SELECT</span> <span class="n">relname</span><span class="p">,</span> <span class="n">pg_table_size</span><span class="p">(</span><span class="n">oid</span><span class="p">)</span> <span class="k">as</span> <span class="n">index_size</span><span class="p">,</span>
  <span class="mf">100</span><span class="o">-</span><span class="p">(</span><span class="n">stattuple</span><span class="mf">.</span><span class="n">pgstatindex</span><span class="p">(</span><span class="n">relname</span><span class="p">))</span><span class="mf">.</span><span class="n">avg_leaf_density</span> <span class="k">AS</span> <span class="n">bloat_ratio</span>
<span class="k">FROM</span> <span class="n">pg_class</span>
<span class="k">WHERE</span> <span class="n">relname</span> <span class="o">~</span> <span class="s1">&#39;test&#39;</span> <span class="k">AND</span> <span class="n">relkind</span> <span class="o">=</span> <span class="s1">&#39;i&#39;</span><span class="p">;</span>

<span class="go">                    relname                    | index_size | bloat_ratio </span>
<span class="go">-----------------------------------------------+------------+-------------</span>
<span class="go"> test_pkey                                     |     524288 |       36.22</span>
<span class="go"> test_inventory_id_idx                         |     376832 |       10.25</span>
<span class="go"> test_rental_date_inventory_id_customer_id_idx |     647168 |       28.04</span></code></pre></figure>

<p>Ok, it totally makes sense there: index <code>test_inventory_id_idx</code> is now 10%
bloated.  First lesson: Do not create your indexes before loading your datas!
Demo:</p>

<figure class="highlight"><pre><code class="language-psql" data-lang="psql"><span></span><span class="gp">pagila=#</span> <span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">test</span><span class="p">;</span>
<span class="gp">pagila=#</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">test</span> <span class="p">(</span><span class="k">LIKE</span> <span class="n">rental</span> <span class="k">INCLUDING</span> <span class="k">DEFAULTS</span> <span class="k">INCLUDING</span> <span class="k">CONSTRAINTS</span><span class="p">);</span>
<span class="gp">pagila=#</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">test</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">rental</span><span class="p">;</span>
<span class="gp">pagila=#</span> <span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">test</span> <span class="k">ADD</span> <span class="k">CONSTRAINT</span> <span class="n">test_pkey</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">rental_id</span><span class="p">);</span> 
<span class="gp">pagila=#</span> <span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">test_inventory_id_idx</span> <span class="k">ON</span> <span class="n">test</span> <span class="p">(</span><span class="n">inventory_id</span><span class="p">);</span>
<span class="gp">pagila=#</span> <span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">test_rental_date_inventory_id_customer_id_idx</span> <span class="k">ON</span> <span class="n">test</span> <span class="p">(</span><span class="n">rental_date</span><span class="p">,</span> <span class="n">inventory_id</span><span class="p">,</span> <span class="n">customer_id</span><span class="p">);</span>

<span class="gp">pagila=#</span> <span class="k">SELECT</span> <span class="n">relname</span><span class="p">,</span> <span class="n">pg_table_size</span><span class="p">(</span><span class="n">oid</span><span class="p">)</span> <span class="k">as</span> <span class="n">index_size</span><span class="p">,</span>
  <span class="mf">100</span><span class="o">-</span><span class="p">(</span><span class="n">stattuple</span><span class="mf">.</span><span class="n">pgstatindex</span><span class="p">(</span><span class="n">relname</span><span class="p">))</span><span class="mf">.</span><span class="n">avg_leaf_density</span> <span class="k">AS</span> <span class="n">bloat_ratio</span>
<span class="k">FROM</span> <span class="n">pg_class</span>
<span class="k">WHERE</span> <span class="n">relname</span> <span class="o">~</span> <span class="s1">&#39;test&#39;</span> <span class="k">AND</span> <span class="n">relkind</span> <span class="o">=</span> <span class="s1">&#39;i&#39;</span><span class="p">;</span>

<span class="go">                    relname                    | index_size | bloat_ratio </span>
<span class="go">-----------------------------------------------+------------+-------------</span>
<span class="go"> test_pkey                                     |     376832 |       10.25</span>
<span class="go"> test_inventory_id_idx                         |     376832 |       10.25</span>
<span class="go"> test_rental_date_inventory_id_customer_id_idx |     524288 |       10.73</span></code></pre></figure>

<h2 id="a-better-query-to-estimate-index-bloat">A better query to estimate index bloat?</h2>

<blockquote>
  <p>Wait, you just showed us you can have the real bloat on indexes, why would I
want a loose estimate from a query relying on stats?!</p>
</blockquote>

<p>Because I feel bad reading the whole index again and again from monitoring
tools every few minutes.  Having a loose estimate is good enough in some cases.
And anyway, I want to dig into this for education :-)</p>

<p>So, I tried to write a query able to give a better estimate of bloat <em>ONLY</em> for
indexes.  I picked some parts of the original bloat query, but rewrote mostly
everything.  Here is the result:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span></span><span class="c1">-- change to the max number of field per index if not default.</span>
<span class="err">\</span><span class="k">set</span> <span class="n">index_max_keys</span> <span class="mi">32</span>
<span class="c1">-- (readonly) IndexTupleData size</span>
<span class="err">\</span><span class="k">set</span> <span class="n">index_tuple_hdr</span> <span class="mi">2</span>
<span class="c1">-- (readonly) ItemIdData size</span>
<span class="err">\</span><span class="k">set</span> <span class="n">item_pointer</span> <span class="mi">4</span>
<span class="c1">-- (readonly) IndexAttributeBitMapData size</span>
<span class="err">\</span><span class="k">set</span> <span class="n">index_attribute_bm</span> <span class="p">(:</span><span class="n">index_max_keys</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span>

<span class="k">SELECT</span> <span class="n">current_database</span><span class="p">(),</span> <span class="n">nspname</span><span class="p">,</span> <span class="k">c</span><span class="p">.</span><span class="n">relname</span> <span class="k">AS</span> <span class="k">table_name</span><span class="p">,</span> <span class="n">index_name</span><span class="p">,</span> <span class="n">bs</span><span class="o">*</span><span class="p">(</span><span class="n">sub</span><span class="p">.</span><span class="n">relpages</span><span class="p">)::</span><span class="nb">bigint</span> <span class="k">AS</span> <span class="n">totalbytes</span><span class="p">,</span>
  <span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">sub</span><span class="p">.</span><span class="n">relpages</span> <span class="o">&lt;=</span> <span class="n">otta</span> <span class="k">THEN</span> <span class="mi">0</span> <span class="k">ELSE</span> <span class="n">bs</span><span class="o">*</span><span class="p">(</span><span class="n">sub</span><span class="p">.</span><span class="n">relpages</span><span class="o">-</span><span class="n">otta</span><span class="p">)::</span><span class="nb">bigint</span> <span class="k">END</span>                                    <span class="k">AS</span> <span class="n">wastedbytes</span><span class="p">,</span>
  <span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">sub</span><span class="p">.</span><span class="n">relpages</span> <span class="o">&lt;=</span> <span class="n">otta</span> <span class="k">THEN</span> <span class="mi">0</span> <span class="k">ELSE</span> <span class="n">bs</span><span class="o">*</span><span class="p">(</span><span class="n">sub</span><span class="p">.</span><span class="n">relpages</span><span class="o">-</span><span class="n">otta</span><span class="p">)::</span><span class="nb">bigint</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="p">(</span><span class="n">bs</span><span class="o">*</span><span class="p">(</span><span class="n">sub</span><span class="p">.</span><span class="n">relpages</span><span class="p">)::</span><span class="nb">bigint</span><span class="p">)</span> <span class="k">END</span> <span class="k">AS</span> <span class="n">realbloat</span>
<span class="k">FROM</span> <span class="p">(</span>
  <span class="k">SELECT</span> <span class="n">bs</span><span class="p">,</span> <span class="n">nspname</span><span class="p">,</span> <span class="n">table_oid</span><span class="p">,</span> <span class="n">index_name</span><span class="p">,</span> <span class="n">relpages</span><span class="p">,</span> <span class="n">coalesce</span><span class="p">(</span>
    <span class="n">ceil</span><span class="p">((</span><span class="n">reltuples</span><span class="o">*</span><span class="p">(:</span><span class="n">item_pointer</span><span class="o">+</span><span class="n">nulldatahdrwidth</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">bs</span><span class="o">-</span><span class="n">pagehdr</span><span class="p">::</span><span class="nb">float</span><span class="p">))</span> <span class="o">+</span>
      <span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">am</span><span class="p">.</span><span class="n">amname</span> <span class="k">IN</span> <span class="p">(</span><span class="s1">&#39;hash&#39;</span><span class="p">,</span><span class="s1">&#39;btree&#39;</span><span class="p">)</span> <span class="k">THEN</span> <span class="mi">1</span> <span class="k">ELSE</span> <span class="mi">0</span> <span class="k">END</span> <span class="p">,</span> <span class="mi">0</span> <span class="c1">-- btree and hash have a metadata reserved block</span>
    <span class="p">)</span> <span class="k">AS</span> <span class="n">otta</span>
  <span class="k">FROM</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="n">maxalign</span><span class="p">,</span> <span class="n">bs</span><span class="p">,</span> <span class="n">nspname</span><span class="p">,</span> <span class="n">relname</span> <span class="k">AS</span> <span class="n">index_name</span><span class="p">,</span> <span class="n">reltuples</span><span class="p">,</span> <span class="n">relpages</span><span class="p">,</span> <span class="n">relam</span><span class="p">,</span> <span class="n">table_oid</span><span class="p">,</span>
      <span class="p">(</span> <span class="n">index_tuple_hdr_bm</span> <span class="o">+</span>
          <span class="n">maxalign</span> <span class="o">-</span> <span class="k">CASE</span> <span class="cm">/* Add padding to the index tuple header to align on MAXALIGN */</span>
            <span class="k">WHEN</span> <span class="n">index_tuple_hdr_bm</span><span class="o">%</span><span class="n">maxalign</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">THEN</span> <span class="n">maxalign</span>
            <span class="k">ELSE</span> <span class="n">index_tuple_hdr_bm</span><span class="o">%</span><span class="n">maxalign</span>
          <span class="k">END</span>
        <span class="o">+</span> <span class="n">nulldatawidth</span> <span class="o">+</span> <span class="n">maxalign</span> <span class="o">-</span> <span class="k">CASE</span> <span class="cm">/* Add padding to the data to align on MAXALIGN */</span>
            <span class="k">WHEN</span> <span class="n">nulldatawidth</span><span class="p">::</span><span class="nb">integer</span><span class="o">%</span><span class="n">maxalign</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">THEN</span> <span class="n">maxalign</span>
            <span class="k">ELSE</span> <span class="n">nulldatawidth</span><span class="p">::</span><span class="nb">integer</span><span class="o">%</span><span class="n">maxalign</span>
          <span class="k">END</span>
      <span class="p">)::</span><span class="nb">numeric</span> <span class="k">AS</span> <span class="n">nulldatahdrwidth</span><span class="p">,</span> <span class="n">pagehdr</span>
    <span class="k">FROM</span> <span class="p">(</span>
      <span class="k">SELECT</span>
        <span class="n">i</span><span class="p">.</span><span class="n">nspname</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">relname</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">reltuples</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">relpages</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">relam</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">starelid</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">attrelid</span> <span class="k">AS</span> <span class="n">table_oid</span><span class="p">,</span>
        <span class="n">current_setting</span><span class="p">(</span><span class="s1">&#39;block_size&#39;</span><span class="p">)::</span><span class="nb">numeric</span> <span class="k">AS</span> <span class="n">bs</span><span class="p">,</span>
        <span class="cm">/* MAXALIGN: 4 on 32bits, 8 on 64bits (and mingw32 ?) */</span>
        <span class="k">CASE</span>
          <span class="k">WHEN</span> <span class="k">version</span><span class="p">()</span> <span class="o">~</span> <span class="s1">&#39;mingw32&#39;</span> <span class="k">OR</span> <span class="k">version</span><span class="p">()</span> <span class="o">~</span> <span class="s1">&#39;64-bit&#39;</span> <span class="k">THEN</span> <span class="mi">8</span>
          <span class="k">ELSE</span> <span class="mi">4</span>
        <span class="k">END</span> <span class="k">AS</span> <span class="n">maxalign</span><span class="p">,</span>
        <span class="cm">/* per page header, fixed size: 20 for 7.X, 24 for others */</span>
        <span class="k">CASE</span> <span class="k">WHEN</span> <span class="k">substring</span><span class="p">(</span><span class="n">current_setting</span><span class="p">(</span><span class="s1">&#39;server_version&#39;</span><span class="p">)</span> <span class="k">FROM</span> <span class="s1">&#39;#&quot;[0-9]+#&quot;%&#39;</span> <span class="k">FOR</span> <span class="s1">&#39;#&#39;</span><span class="p">)::</span><span class="nb">integer</span> <span class="o">&gt;</span> <span class="mi">7</span>
          <span class="k">THEN</span> <span class="mi">24</span>
          <span class="k">ELSE</span> <span class="mi">20</span>
        <span class="k">END</span> <span class="k">AS</span> <span class="n">pagehdr</span><span class="p">,</span>
        <span class="cm">/* per tuple header: add index_attribute_bm if some cols are null-able */</span>
        <span class="k">CASE</span> <span class="k">WHEN</span> <span class="k">max</span><span class="p">(</span><span class="n">coalesce</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">stanullfrac</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span>
          <span class="k">THEN</span> <span class="p">:</span><span class="n">index_tuple_hdr</span>
          <span class="k">ELSE</span> <span class="p">:</span><span class="n">index_tuple_hdr</span> <span class="o">+</span> <span class="p">:</span><span class="n">index_attribute_bm</span>
        <span class="k">END</span> <span class="k">AS</span> <span class="n">index_tuple_hdr_bm</span><span class="p">,</span>
        <span class="cm">/* data len: we remove null values save space using it fractionnal part from stats */</span>
        <span class="k">sum</span><span class="p">(</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">coalesce</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">stanullfrac</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">coalesce</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">stawidth</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span> <span class="p">)</span> <span class="k">AS</span> <span class="n">nulldatawidth</span>
      <span class="k">FROM</span> <span class="n">pg_attribute</span> <span class="k">AS</span> <span class="n">a</span>
        <span class="k">JOIN</span> <span class="n">pg_statistic</span> <span class="k">AS</span> <span class="n">s</span> <span class="k">ON</span> <span class="n">s</span><span class="p">.</span><span class="n">starelid</span><span class="o">=</span><span class="n">a</span><span class="p">.</span><span class="n">attrelid</span> <span class="k">AND</span> <span class="n">s</span><span class="p">.</span><span class="n">staattnum</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">attnum</span>
        <span class="k">JOIN</span> <span class="p">(</span>
          <span class="k">SELECT</span> <span class="n">nspname</span><span class="p">,</span> <span class="n">relname</span><span class="p">,</span> <span class="n">reltuples</span><span class="p">,</span> <span class="n">relpages</span><span class="p">,</span> <span class="n">indrelid</span><span class="p">,</span> <span class="n">relam</span><span class="p">,</span> <span class="n">regexp_split_to_table</span><span class="p">(</span><span class="n">indkey</span><span class="p">::</span><span class="nb">text</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)::</span><span class="nb">smallint</span> <span class="k">AS</span> <span class="n">attnum</span>
          <span class="k">FROM</span> <span class="n">pg_index</span>
            <span class="k">JOIN</span> <span class="n">pg_class</span> <span class="k">ON</span> <span class="n">pg_class</span><span class="p">.</span><span class="n">oid</span><span class="o">=</span><span class="n">pg_index</span><span class="p">.</span><span class="n">indexrelid</span>
            <span class="k">JOIN</span> <span class="n">pg_namespace</span> <span class="k">ON</span> <span class="n">pg_namespace</span><span class="p">.</span><span class="n">oid</span> <span class="o">=</span> <span class="n">pg_class</span><span class="p">.</span><span class="n">relnamespace</span>
        <span class="p">)</span> <span class="k">AS</span> <span class="n">i</span> <span class="k">ON</span> <span class="n">i</span><span class="p">.</span><span class="n">indrelid</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">attrelid</span> <span class="k">AND</span> <span class="n">a</span><span class="p">.</span><span class="n">attnum</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">attnum</span>
      <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">attnum</span> <span class="o">&gt;</span> <span class="mi">0</span>
      <span class="k">GROUP</span> <span class="k">BY</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span>
    <span class="p">)</span> <span class="k">AS</span> <span class="n">s1</span>
  <span class="p">)</span> <span class="k">AS</span> <span class="n">s2</span>
    <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">pg_am</span> <span class="n">am</span> <span class="k">ON</span> <span class="n">s2</span><span class="p">.</span><span class="n">relam</span> <span class="o">=</span> <span class="n">am</span><span class="p">.</span><span class="n">oid</span>
<span class="p">)</span> <span class="k">as</span> <span class="n">sub</span>
<span class="k">JOIN</span> <span class="n">pg_class</span> <span class="k">c</span> <span class="k">ON</span> <span class="k">c</span><span class="p">.</span><span class="n">oid</span><span class="o">=</span><span class="n">sub</span><span class="p">.</span><span class="n">table_oid</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span></code></pre></figure>

<p>How does it perform compared to the actual values? Let’s go back to a bloated
situation:</p>

<figure class="highlight"><pre><code class="language-psql" data-lang="psql"><span></span><span class="gp">pagila=#</span> <span class="k">TRUNCATE</span> <span class="n">test</span> <span class="p">;</span>
<span class="gp">pagila=#</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">test</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">rental</span><span class="p">;</span>
<span class="gp">pagila=#</span> <span class="k">SELECT</span> <span class="n">relname</span><span class="p">,</span> <span class="n">pg_table_size</span><span class="p">(</span><span class="n">oid</span><span class="p">)</span> <span class="k">as</span> <span class="n">index_size</span><span class="p">,</span>
  <span class="mf">100</span><span class="o">-</span><span class="p">(</span><span class="n">stattuple</span><span class="mf">.</span><span class="n">pgstatindex</span><span class="p">(</span><span class="n">relname</span><span class="p">))</span><span class="mf">.</span><span class="n">avg_leaf_density</span> <span class="k">AS</span> <span class="n">bloat_ratio</span>
<span class="k">FROM</span> <span class="n">pg_class</span>
<span class="k">WHERE</span> <span class="n">relname</span> <span class="o">~</span> <span class="s1">&#39;test&#39;</span> <span class="k">AND</span> <span class="n">relkind</span> <span class="o">=</span> <span class="s1">&#39;i&#39;</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="mf">1</span><span class="p">;</span>
<span class="gp">pagila=#</span> <span class="k">ANALYZE</span> <span class="n">test</span><span class="p">;</span>

<span class="go">                    relname                    | index_size | bloat_ratio </span>
<span class="go">-----------------------------------------------+------------+-------------</span>
<span class="go"> test_inventory_id_idx                         |     507904 |       34.11</span>
<span class="go"> test_pkey                                     |     376832 |       10.25</span>
<span class="go"> test_rental_date_inventory_id_customer_id_idx |     630784 |       26.14</span></code></pre></figure>

<p>I created the file “~/tmp/bloat_index.sql” with this estimated indexes bloat
query filtering on table <code>test</code>, here is its result:</p>

<figure class="highlight"><pre><code class="language-psql" data-lang="psql"><span></span><span class="gp">pagila=#</span> <span class="kp">\i</span> <span class="ss">~/tmp/bloat_index.sql</span> 
<span class="go"> current_database | nspname | table_name |                  index_name                   | totalbytes | wastedbytes |      realbloat      </span>
<span class="go">------------------+---------+------------+-----------------------------------------------+------------+-------------+---------------------</span>
<span class="go"> pagila           | public  | test       | test_inventory_id_idx                         |     507904 |      172032 | 33.8709677419354839</span>
<span class="go"> pagila           | public  | test       | test_pkey                                     |     376832 |       40960 | 10.8695652173913043</span>
<span class="go"> pagila           | public  | test       | test_rental_date_inventory_id_customer_id_idx |     630784 |      172032 | 27.2727272727272727</span></code></pre></figure>

<p>Well, pretty close :-)</p>

<p>Let’s REINDEX:</p>

<figure class="highlight"><pre><code class="language-psql" data-lang="psql"><span></span><span class="gp">pagila=#</span> <span class="k">REINDEX</span> <span class="k">TABLE</span> <span class="n">test</span><span class="p">;</span>
<span class="gp">pagila=#</span> <span class="k">ANALYZE</span> <span class="n">test</span><span class="p">;</span>
<span class="gp">pagila=#</span> <span class="k">SELECT</span> <span class="n">relname</span><span class="p">,</span> <span class="n">pg_table_size</span><span class="p">(</span><span class="n">oid</span><span class="p">)</span> <span class="k">as</span> <span class="n">index_size</span><span class="p">,</span>
  <span class="mf">100</span><span class="o">-</span><span class="p">(</span><span class="n">stattuple</span><span class="mf">.</span><span class="n">pgstatindex</span><span class="p">(</span><span class="n">relname</span><span class="p">))</span><span class="mf">.</span><span class="n">avg_leaf_density</span> <span class="k">AS</span> <span class="n">bloat_ratio</span>
<span class="k">FROM</span> <span class="n">pg_class</span>
<span class="k">WHERE</span> <span class="n">relname</span> <span class="o">~</span> <span class="s1">&#39;test&#39;</span> <span class="k">AND</span> <span class="n">relkind</span> <span class="o">=</span> <span class="s1">&#39;i&#39;</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="mf">1</span><span class="p">;</span>

<span class="go">                    relname                    | index_size | bloat_ratio </span>
<span class="go">-----------------------------------------------+------------+-------------</span>
<span class="go"> test_inventory_id_idx                         |     376832 |       10.25</span>
<span class="go"> test_pkey                                     |     376832 |       10.25</span>
<span class="go"> test_rental_date_inventory_id_customer_id_idx |     524288 |       10.73</span>

<span class="gp">pagila=#</span> <span class="kp">\i</span> <span class="ss">~/tmp/bloat_index.sql</span> 
<span class="go"> current_database | nspname | table_name |                  index_name                   | totalbytes | wastedbytes |      realbloat      </span>
<span class="go">------------------+---------+------------+-----------------------------------------------+------------+-------------+---------------------</span>
<span class="go"> pagila           | public  | test       | test_inventory_id_idx                         |     376832 |       40960 | 10.8695652173913043</span>
<span class="go"> pagila           | public  | test       | test_pkey                                     |     376832 |       40960 | 10.8695652173913043</span>
<span class="go"> pagila           | public  | test       | test_rental_date_inventory_id_customer_id_idx |     524288 |       65536 | 12.5000000000000000</span></code></pre></figure>

<p>Not bad.</p>

<p>Let’s create some bloat. The table is approx. 160,000 rows, so the following
query updates ~10% of the table:</p>

<figure class="highlight"><pre><code class="language-psql" data-lang="psql"><span></span><span class="gp">pagila=#</span> <span class="k">UPDATE</span> <span class="n">test</span> <span class="k">SET</span> <span class="n">rental_date</span> <span class="o">=</span> <span class="k">current_timestamp</span> <span class="k">WHERE</span> <span class="n">rental_id</span> <span class="o">&lt;</span> <span class="mf">3200</span> <span class="k">AND</span> <span class="n">rental_id</span><span class="o">%</span><span class="mf">2</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span>
<span class="gp">pagila=#</span> <span class="k">ANALYZE</span> <span class="n">test</span> <span class="p">;</span>

<span class="gp">pagila=#</span> <span class="k">SELECT</span> <span class="n">relname</span><span class="p">,</span> <span class="n">pg_table_size</span><span class="p">(</span><span class="n">oid</span><span class="p">)</span> <span class="k">as</span> <span class="n">index_size</span><span class="p">,</span>
  <span class="mf">100</span><span class="o">-</span><span class="p">(</span><span class="n">stattuple</span><span class="mf">.</span><span class="n">pgstatindex</span><span class="p">(</span><span class="n">relname</span><span class="p">))</span><span class="mf">.</span><span class="n">avg_leaf_density</span> <span class="k">AS</span> <span class="n">bloat_ratio</span>
<span class="k">FROM</span> <span class="n">pg_class</span>
<span class="k">WHERE</span> <span class="n">relname</span> <span class="o">~</span> <span class="s1">&#39;test&#39;</span> <span class="k">AND</span> <span class="n">relkind</span> <span class="o">=</span> <span class="s1">&#39;i&#39;</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="mf">1</span><span class="p">;</span>

<span class="go">                    relname                    | index_size | bloat_ratio </span>
<span class="go">-----------------------------------------------+------------+-------------</span>
<span class="go"> test_inventory_id_idx                         |     475136 |       22.42</span>
<span class="go"> test_pkey                                     |     450560 |       18.04</span>
<span class="go"> test_rental_date_inventory_id_customer_id_idx |     598016 |       14.26</span>
<span class="go">(3 rows)</span>

<span class="gp">pagila=#</span> <span class="kp">\i</span> <span class="ss">~/tmp/bloat_index.sql</span> 
<span class="go"> current_database | nspname | table_name |                  index_name                   | totalbytes | wastedbytes |      realbloat      </span>
<span class="go">------------------+---------+------------+-----------------------------------------------+------------+-------------+---------------------</span>
<span class="go"> pagila           | public  | test       | test_inventory_id_idx                         |     475136 |      139264 | 29.3103448275862069</span>
<span class="go"> pagila           | public  | test       | test_pkey                                     |     450560 |      114688 | 25.4545454545454545</span>
<span class="go"> pagila           | public  | test       | test_rental_date_inventory_id_customer_id_idx |     598016 |      139264 | 23.2876712328767123</span>
<span class="go">(3 rows)</span></code></pre></figure>

<p>Erk, not so good. Moar bloat?</p>

<figure class="highlight"><pre><code class="language-psql" data-lang="psql"><span></span><span class="gp">pagila=#</span> <span class="k">UPDATE</span> <span class="n">test</span> <span class="k">SET</span> <span class="n">rental_date</span> <span class="o">=</span> <span class="k">current_timestamp</span> <span class="k">WHERE</span> <span class="n">rental_id</span><span class="o">%</span><span class="mf">2</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span>
<span class="gp">pagila=#</span> <span class="k">ANALYZE</span> <span class="n">test</span> <span class="p">;</span>
<span class="gp">pagila=#</span> <span class="k">SELECT</span> <span class="n">relname</span><span class="p">,</span> <span class="n">pg_table_size</span><span class="p">(</span><span class="n">oid</span><span class="p">)</span> <span class="k">as</span> <span class="n">index_size</span><span class="p">,</span>
  <span class="mf">100</span><span class="o">-</span><span class="p">(</span><span class="n">stattuple</span><span class="mf">.</span><span class="n">pgstatindex</span><span class="p">(</span><span class="n">relname</span><span class="p">))</span><span class="mf">.</span><span class="n">avg_leaf_density</span> <span class="k">AS</span> <span class="n">bloat_ratio</span>
<span class="k">FROM</span> <span class="n">pg_class</span>
<span class="k">WHERE</span> <span class="n">relname</span> <span class="o">~</span> <span class="s1">&#39;test&#39;</span> <span class="k">AND</span> <span class="n">relkind</span> <span class="o">=</span> <span class="s1">&#39;i&#39;</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="mf">1</span><span class="p">;</span>

<span class="go">                    relname                    | index_size | bloat_ratio </span>
<span class="go">-----------------------------------------------+------------+-------------</span>
<span class="go"> test_inventory_id_idx                         |     745472 |       55.48</span>
<span class="go"> test_pkey                                     |     737280 |       54.98</span>
<span class="go"> test_rental_date_inventory_id_customer_id_idx |     925696 |       49.96</span>
<span class="go">(3 rows)</span>

<span class="gp">pagila=#</span> <span class="kp">\i</span> <span class="ss">~/tmp/bloat_index.sql</span> 
<span class="go"> current_database | nspname | table_name |                  index_name                   | totalbytes | wastedbytes |      realbloat      </span>
<span class="go">------------------+---------+------------+-----------------------------------------------+------------+-------------+---------------------</span>
<span class="go"> pagila           | public  | test       | test_inventory_id_idx                         |     745472 |      409600 | 54.9450549450549451</span>
<span class="go"> pagila           | public  | test       | test_pkey                                     |     737280 |      401408 | 54.4444444444444444</span>
<span class="go"> pagila           | public  | test       | test_rental_date_inventory_id_customer_id_idx |     925696 |      466944 | 50.4424778761061947</span>
<span class="go">(3 rows)</span></code></pre></figure>

<p>Well, better again.</p>

<h2 id="conclusion">Conclusion</h2>

<p>This new query performs much better for indexes than the usual one everyone
knew for a long time.  But it isn’t perfect, showing sometimes some quite wrong
results.</p>

<p>First issue, this query doesn’t make any difference between branch nodes and
leaves in indexes.  Rows values and references are kept in leaves, and only a
fractional part of them are in branches.  I should do some more tests with
larger indexes to see how it behaves with a lot of branch nodes.  As the number
of branch nodes is supposed to be a logarithm of the total number of rows,
maybe we could include some more guessing in the optimal index size computing.</p>

<p>Second issue…keep in mind it is based on statistics.</p>

<p>Anyway, as useful as this query can be, at least it has been funny to dive in
indexes and pages guts.</p>

<p>As a side note, I had been surprised to see that padding to <code>MAXALIGN</code> was
applied on both tuple header AND tuple data.  My understanding is that for each
row in an index leave page, we have:</p>
<ul>
  <li>the item_pointer at the beginning of the page,</li>
  <li>the tuple header + data at the end of the page that must be aligned on
<code>MAXALIGN</code>.</li>
</ul>

<p>Why ain’t they padded <em>together</em> to <code>MAXALIGN</code>? Wouldn’t this save
some space?</p>

<p>Thank you for reading till the end! Cheers, see you maybe in another post about
table bloat next time ;-)</p>


  
<div id="comments">
  <hr />
  <a class="comments" name="comments">Comments</a>&nbsp;Leave a comment <a href="mailto:ioguix+blog@gmail.com?subject=Post:%20Playing%20with%20indexes%20and%20better%20bloat%20estimate">by email</a> or <a href="#disqus_thread">Disqus</a>
  <p>Note: I only publish your name/pseudo, mail subject and content. I will NOT publish your email address.</p>

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      
      
      <div class="comment" style="margin-left: 0px">
        <a name="comment-019"><strong>eggyknap</strong></a>&nbsp;<a href="mailto:ioguix+reply-019@gmail.com?subject=Post:%20Playing%20with%20indexes%20and%20better%20bloat%20estimate">reply</a>
        
        <div class="meta_infos">Sat, 29 Mar 2014 05:45:45 +0100</div>

         <p>The check_postgres project welcomes patches! :)</p>
 
      </div>
    
  
    
      
      
      <div class="comment" style="margin-left: 0px">
        <a name="comment-020"><strong>Josh Berkus</strong></a>&nbsp;<a href="mailto:ioguix+reply-020@gmail.com?subject=Post:%20Playing%20with%20indexes%20and%20better%20bloat%20estimate">reply</a>
        
        <div class="meta_infos">Tue, 01 Apr 2014 01:58:01 +0200</div>

         <p>Thanks for posting this!  I’ve known for a while that the index bloat calculation was faulty, but haven’t quite known what was wrong with it.</p>

<p>I’m working on a 2nd bloat calculation involving dead row counts – just for tables,though.</p>

 
      </div>
    
  
    
      
      
      <div class="comment" style="margin-left: 0px">
        <a name="comment-021"><strong>Josh Berkus</strong></a>&nbsp;<a href="mailto:ioguix+reply-021@gmail.com?subject=Post:%20Playing%20with%20indexes%20and%20better%20bloat%20estimate">reply</a>
        
        <div class="meta_infos">Tue, 01 Apr 2014 02:10:31 +0200</div>

         <p>Actually, there’s some bugs in the query version as you’ve written it above:</p>

<ul>
  <li>It’s <code>\set</code>, not <code>\SET</code></li>
  <li><code>index_tuple_hdr</code> is missing the <code>:</code> in two places.</li>
</ul>

<p>Thanks!</p>
 
      </div>
    
  
    
      
      
      <div class="comment" style="margin-left: 20px">
        <a name="comment-022"><strong>ioguix</strong></a>&nbsp;<a href="mailto:ioguix+reply-022@gmail.com?subject=Post:%20Playing%20with%20indexes%20and%20better%20bloat%20estimate">reply</a>
        
        <div class="meta_infos">Thu, 03 Apr 2014 15:43:33 +0200</div>

         <p>Josh,</p>

<p>About <code>index_tuple_hdr</code>, I just realize I used it as a field name AND a psql variable, my bad. See the code bellow this comment in the query:</p>

<p><code>/* per tuple header: add index_attribute_bm if some cols are null-able */</code></p>

<p>So if you are referring to <code>index_tuple_hdr</code> at lines 11, 13 and 14, those are referring to the computed field, so no <code>:</code>, it would produce bad stats with indexes on NULLable cols.</p>

<p>I fixed to query to remove this confusion.</p>

<p>Good catch about the <code>\SET</code>! It appears there was some magic in my old blog system transforming it in uppercase. I’ll not investigate further as I moved to jekyll…</p>

<p>Thanks!</p>
 
      </div>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</div>


  <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname  = 'ioguix';
    var disqus_identifier = "2014-03-28-Playing-with-indexes-and-better-bloat-estimate";

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


</div>




  <div class="footer">
    © 2010 - 2016: Jehan-Guillaume (ioguix) de Rorthais
    <a href="mailto:ioguix+blog@gmail.com"><i class="fa fa-envelope"></i></a>
    <a href="http://github.com/ioguix/"><i class="fa fa-github"></i></a>
    <a href="http://blog.ioguix.net/feed.xml"><i class="fa fa-rss"></i></a>
  </div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-52084735-1', 'auto');
  ga('send', 'pageview');

</script>


</body>
</html>
